---
layout: post
title: CS271 Final Prep
category: school
---

I'm going through all the self-check exercises for this class.

<h3 class="anchor" id="week7">Week 7</h3>

Here is a partial data segment:

{% highlight nasm %}
	MAX = 50
.data
	...
	list 	DWORD MAX DUP(0)
	a 	DWORD 25
	b 	DWORD 15
	...
{% endhighlight %}



1\. Given: the address of `list` is `0x0300`.

a. **What is the (hexadecimal) address of `a`?**

>[answer]

b. **What is the (hexadecimal) address of the 33rd element of `list`?** (Hint: in C or Java, the 33rd element is `list[32]`)

>[answer]

---

2\. Given the following partial data segment:

{% highlight nasm %}
.data
	loVal 	DWORD ?
	hiVal 	DWORD ?
	randVal DWORD ?
.code
main PROC
	call 	Randomize ; from the Irvine library
; Code to get loVal and hiVal from the user goes here.
	push 	loVal
	push 	hiVal
	push 	OFFSET randVal
	call 	nextRand
; More main procedure code
	exit
main ENDP
{% endhighlight %}

**Write the `nextRand` procedure so that it satisfies the following header documentation.** You may use appropriate
Irvine library procedures. Note that used registers must be saved and restored.

{% highlight nasm %}
[answer]
; Procedure nextRand
; Procedure to get the nest random number in the range specified by the user.
; Receives parameters on the system stack (in the order pushed):
; Lowest acceptable value (loVal)
; Highest acceptable value (hiVal)
; Address of return value
; Preconditions: loVal < hiVal
; Registers used: none
{% endhighlight %}









<h3 class="anchor" id="week8">Week 8</h3>

Given the following partial data segment, which starts at address `0x0200` :

{% highlight nasm %}
.data
	list 	DWORD 	1, 2, 6, 24, 120, 720, 5040, 40320
	x 	DWORD 	LENGTHOF list
	y 	DWORD 	SIZEOF list
{% endhighlight %}

1\. **`x` contains**

>[Answer]

2\. **`y` contains**

>[Answer]

3\. **The address of `x` is**

>[Answer]

4\. Given this code fragment:

{% highlight nasm %}
mov 	esi, OFFSET list
mov 	eax, [esi+5*TYPE list]
{% endhighlight %}

**`eax` contains**

>[Answer]

5\. Given this code fragment:

{% highlight nasm %}
mov 	esi, OFFSET list
mov 	ebx, y
sub 	ebx, TYPE y
add 	esi, ebx
{% endhighlight %}

**`[esi]` contains**

>[Answer]

6\. Given this code fragment:

{% highlight nasm %}
mov 	esi, OFFSET list
mov 	ebx, y
sub 	ebx, TYPE y
add 	esi, ebx
mov 	al, BYTE PTR [esi+1]
{% endhighlight %}

**The `AL` register contains**
>[Answer]

---

Given the following partial data segment, which starts at address 0x0200 :

{% highlight nasm %}
.data
	matrix 	DWORD 20 DUP(5 DUP(?))
	x 	DWORD LENGTHOF matrix
	y 	DWORD SIZEOF matrix
	pal 	BYTE ”Hello world.”,0
	len 	DWORD LENGTHOF pal
{% endhighlight %}

1\. **`x` contains**

>[Answer]

2\. **`y` contains** 

>[Answer]

3\. In high-level language notation, the 3rd element of the 9th row is referenced as `matrix[8][2]`

**The address of `matrix[8][2]` is**

>[Answer]

4\. Given this code fragment:

{% highlight nasm %}
.code
	mov 	esi, OFFSET pal
	mov 	ecx, len
	sub 	ecx, 2
	cld
one:
	lodsb
	call 	WriteChar
	loop 	one
	mov 	ecx, len
	sub 	ecx, 2
	std
two:
	lodsb
	call WriteChar
	loop two
{% endhighlight %}

`WriteChar` displays the character in the `AL` register. **What is displayed?**

>[Answer]















<h3 class="anchor" id="week9">Week 9</h3>

1\. Suppose that a program's data and executable code require 2048 bytes of memory. A new section of
code must be added; it will be used with various values 30 times during the execution of a program.
When implemented as a macro, the macro code requires 48 bytes of memory. When implemented as
a procedure, the procedure code requires 128 bytes (including parameter-passing, etc.), and each
procedure call requires 5 bytes.

**How many bytes of memory will the entire program require if the new code is added as a macro?**

>[Answer]

**How many bytes of memory will the entire program require if the new code is added as a procedure?**

>[Answer]

2\. a) **Write a MASM macro that calculates x<sup>2</sup> – 1 for its parameter x, and stores the result in memory at the second parameter. The caller passes x by value, and the result variable by address.**

{% highlight nasm %}
[answer]
{% endhighlight %}

b) **Invoke the macro of part a) with 68 and memory location result.**

{% highlight nasm %}
[answer]
{% endhighlight %}

3\. The code below uses the `Space` macro which simply displays the number of blank spaces specified by
its argument. **What output is generated by this MASM "program"?**

{% highlight nasm %}
main PROC
	push 	3
	push 	7
	call 	rcrsn
	exit
main ENDP

rcrsn PROC
	push 	ebp
	mov 	ebp,esp
	mov 	eax,[ebp + 12]
	mov 	ebx,[ebp+8]
	cmp 	eax,ebx
	jl 		recurse
	jmp 	quit
recurse:
	inc 	eax
	push 	eax
	push 	ebx
	call 	rcrsn
	mov 	eax,[ebp + 12]
	call 	WriteDec
	Space 	2
quit:
	pop 	ebp
	ret 	8
rcrsn ENDP
{% endhighlight %}

4\. It takes one clock cycle to perform an addition operation in the 4-bit ripple-carry adder (see
Lecture slide #7). **How many clock cycles will it take for one addition instruction to be executed
in a 64-bit ripple-carry adder?**

>[answer] clock cycles

5\. **What is the (string) result of adding the following digit string, digit by digit?**

{% highlight nasm %}
a BYTE ”2458”,0
b BYTE ”6301”,0
{% endhighlight %}

>[Answer]

---

1\. **Convert the following infix expressions to RPN:**

{% highlight c %}
(a + b) - (c + d) * e
> 

a + b * c - d * e / f + h 
>
{% endhighlight %}

2\. **Convert the following postfix expressions to infix:**

{% highlight c %}
abc+d*+ 
>

ab+cd/e*f/+g-h*
>
{% endhighlight %}

3\. Let `a = 5, b = 7, c = 4, d = 2, e = 3, f = 1, g = 6`. **Evaluate the following RPN expressions:**

{% highlight c %}
ab+c-d*
>

ab+c+de*f/g-*
>
{% endhighlight %}

4\. **Implement the statement `G = (A + B x C) / (D - E x F)` in the IA-32 floating-point unit.** It’s not necessary to write a complete program or procedure, just write an FPU code fragment.

{% highlight nasm %}
[answer]
{% endhighlight %}
















<h3 class="anchor" id="week10">Week 10</h3>

1\. Given a CISC machine with a 2 GHz clock (i.e., the clock ticks 2 billion times per second). This
particular computer uses MASM-like instructions with the following timings:

`add` *reg, mem* - 9 clock cycles (i.e., the ADD microprogram has 9 instructions)  
`add` *reg,immed* - 3 clock cycles  
`loop` *label* - 7 clock cycles

Here’s a short code fragment to sum the elements of a numeric array:

{% highlight nasm %}
	mov 	eax,0 				;initialize sum
	mov 	ecx,MAX_SIZE 		;initialize loop counter
	mov 	esi,OFFSET list 	;initialize array pointer
more:
	add 	eax,[esi] 		;add current list element
	add 	esi,4 			;move array pointer to next element
	loop 	more 			;auto-decrement ecx, jump to more,
							;if ecx ≠ 0
{% endhighlight %}

Assume unlimited array size.
**After initialization, how many array elements could be processed in 1 ms. (1 ms. = 1/1000 sec)?**

>[answer] array elements

2\. Given a RISC machine with a 2 GHz clock (i.e., the clock ticks 2 billion times per second). This
particular computer uses an instruction cache, a data cache, an operand fetch unit, and an operand
store unit. The instruction set includes simple instructions with the following timings:

`set` *reg, immed* 1 clock cycle
`load` *reg,mem* 2 clock cycles
`add` *reg,reg* 2 clock cycles
`add` *reg,immed* 1 clock cycle
`loop` *label* 3 clock cycles

Here’s a short code fragment to sum the elements of a numeric array:

{% highlight nasm %}
.code
	set 	r1,0 			;initialize sum
	set 	r2,MAX_SIZE 		;initialize loop counter
	set 	r3,@list 		;initialize array pointer
more:
	load 	r4,[r3] 		;fetch current list element
	add 	r1,r4 			;add current list element
	add 	r3,4 			;move array pointer to next element
	loop 	more 			;auto-decrement r2, jump to more,
					;if r2 ≠ 0
{% endhighlight %}

Assume unlimited array size.
**After initialization, how many array elements could be processed in 1 ms. (1 ms. = 1/1000 sec)**

>[answer] array elements

3\. Cite and explain two major reasons that software parallelism has not kept pace with developments
in hardware parallelism.

>Parallelizability of algorithms
>
>- Number of processors
>- Trade-offs and efficiency
>- Sequential/parallel parts
>
>Some parts of a program are parallelizable, others must be done sequentially.
>
>
>Amdahl's law  
>`n` = number of processors  
>`f` = fraction of code that is sequential  
>`T` = time to process entire algorithm sequentially (one processor)


<img class="center" src="{{ site.url }}/assets/comp/speedup.png"/>

<img class="center" src="{{ site.url }}/assets/comp/amdahl.png"/>
