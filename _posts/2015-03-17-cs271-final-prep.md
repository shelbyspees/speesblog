---
layout: post
title: CS271 Final Prep
category:
---

I'm going through all the self-check exercises for this class.

###Week 6

###Week 7

###Week 8

###Week 9

1\. Suppose that a program's data and executable code require 2048 bytes of memory. A new section of
code must be added; it will be used with various values 30 times during the execution of a program.
When implemented as a macro, the macro code requires 48 bytes of memory. When implemented as
a procedure, the procedure code requires 128 bytes (including parameter-passing, etc.), and each
procedure call requires 5 bytes.

***How many bytes of memory will the entire program require if the new code is added as a macro?***

>[Answer]

***How many bytes of memory will the entire program require if the new code is added as a procedure?***

>[Answer]

2\. ***A) Write a MASM macro that calculates x^2 – 1 for its parameter x, and stores the result in memory at the second parameter. The caller passes x by value, and the result variable by address.***

{% highlight nasm %}
[answer]
{% endhighlight %}

***B) Invoke the macro of part A) with 68 and memory location result.***

{% highlight nasm %}
[answer]
{% endhighlight %}

3\. The code below uses the Space macro which simply displays the number of blank spaces specified by
its argument. ***What output is generated by this MASM "program"?***

{% highlight nasm %}
main PROC
	push 	3
	push 	7
	call 	rcrsn
	exit
main ENDP

rcrsn PROC
	push 	ebp
	mov 	ebp,esp
	mov 	eax,[ebp + 12]
	mov 	ebx,[ebp+8]
	cmp 	eax,ebx
	jl 		recurse
	jmp 	quit
recurse:
	inc 	eax
	push 	eax
	push 	ebx
	call 	rcrsn
	mov 	eax,[ebp + 12]
	call 	WriteDec
	Space 	2
quit:
	pop 	ebp
	ret 	8
rcrsn ENDP
{% endhighlight %}

4\. It takes one clock cycle to perform an addition operation in the 4-bit ripple-carry adder (see
Lecture slide #7). ***How many clock cycles will it take for one addition instruction to be executed
in a 64-bit ripple-carry adder?***

> [answer] clock cycles

###Week 10

1\. Given a CISC machine with a 2 GHz clock (i.e., the clock ticks 2 billion times per second). This
particular computer uses MASM-like instructions with the following timings:

`add` *reg, mem* - 9 clock cycles (i.e., the ADD microprogram has 9 instructions)  
`add` *reg,immed* - 3 clock cycles  
`loop` *label* - 7 clock cycles

Here’s a short code fragment to sum the elements of a numeric array:

{% highlight nasm %}
	mov 	eax,0 				;initialize sum
	mov 	ecx,MAX_SIZE 		;initialize loop counter
	mov 	esi,OFFSET list 	;initialize array pointer
more:
	add 	eax,[esi] 		;add current list element
	add 	esi,4 			;move array pointer to next element
	loop 	more 			;auto-decrement ecx, jump to more,
							;if ecx ≠ 0
{% endhighlight %}

Assume unlimited array size.
**After initialization, how many array elements could be processed in 1 ms. (1 ms. = 1/1000 sec)?**

>[answer]

4\. Cite and explain two major reasons that software parallelism has not kept pace with developments
in hardware parallelism.

>Amdahl's law  
>`n` = number of processors  
>`f` = fraction of code that is sequential  
>`T` = time to process entire algorithm sequentially (one processor)
>
>Parallelizability of algorithms
>
>- Number of processors
>- Trade-offs and efficiency
>- Sequential/parallel parts

<img class="center" src="{{ site.url }}/assets/comp/speedup.png"/>

<img class="center" src="{{ site.url }}/assets/comp/amdahl.png"/>
